# Chapter 14 Review Questions - Grouped by Topic


---


## Addressing Modes


---

# Computer Architecture: Chapter 14 Review Questions

Question 1: Which of the following addressing modes requires the most memory references to fetch the operand, assuming no multilevel indirection?
A. Direct Addressing
B. Register Indirect Addressing
C. Indirect Addressing
D. Displacement Addressing

Correct Answer: C
Explanation: Based on Table 14.1 and the descriptions on pages 6-9, Indirect Addressing is the most memory-intensive. It requires two memory references to fetch the operand: one to fetch the address of the operand from the memory location specified in the instruction, and a second to fetch the operand itself from that address. Direct and Displacement addressing require one memory reference for the operand. Register Indirect also requires one memory reference, as the pointer is held in a register, not memory.

---

Question 2: According to the summary table of Basic Addressing Modes (Table 14.1), what is the principal advantage of Immediate Addressing?
A. Large address space
B. No memory reference to fetch the operand
C. Flexibility
D. Simplicity

Correct Answer: B
Explanation: As shown in Table 14.1 on page 4, the principal advantage of Immediate Addressing is "No memory reference". This is because the operand value is part of the instruction itself. This saves a memory or cache cycle that would otherwise be needed to fetch the operand, speeding up execution. The other options are advantages of different modes: Large address space (Indirect, Register Indirect), Flexibility (Displacement), and Simplicity (Direct).

---

Question 3: In the diagram for Displacement Addressing (Figure 14.1f), how is the effective address of the operand calculated?
A. The operand is located at the address specified by the contents of register R.
B. The operand is located at the memory address A specified in the instruction.
C. The operand is located at the address found in memory location A, which is then added to the contents of register R.
D. The effective address is the sum of the value A from the instruction and the contents of register R.

Correct Answer: D
Explanation: Figure 14.1f on page 3 and the formula on page 10, EA = A + (R), clearly show that Displacement Addressing calculates the effective address by adding a displacement value (A) contained in the instruction to the contents of a specified register (R). This combined value points to the operand in memory.

---

Question 4: What is the primary disadvantage of Direct Addressing?
A. Limited address space
B. Multiple memory references
C. High complexity
D. Inability to use registers

Correct Answer: A
Explanation: As stated on page 6 and in Table 14.1, the main limitation of Direct Addressing is that it provides a limited address space. The size of the address field within the instruction itself determines the maximum memory address that can be referenced. For example, if the address field is 16 bits, only 2^16 memory locations can be directly addressed.

---

Question 5: Which type of addressing is most suitable for handling iterative operations on arrays?
A. Relative Addressing
B. Base-Register Addressing
C. Indexing
D. Stack Addressing

Correct Answer: C
Explanation: Page 13 states that an important use of Indexing is "to provide an efficient mechanism for performing iterative operations." In array processing, the base address of the array can be held in the instruction's address field (A), while a register (R) holds the index. The index register can be easily incremented or decremented (as in autoindexing) to step through the array elements.

---

Question 6: In Relative Addressing, the displacement value in the instruction is added to the contents of which register to calculate the effective address?
A. A general-purpose register specified in the instruction
B. The Program Counter (PC)
C. The Stack Pointer (SP)
D. A base register holding the start of a memory segment

Correct Answer: B
Explanation: As defined on page 11, Relative Addressing is a form of displacement addressing where "the implicitly referenced register is the program counter (PC)." The effective address is calculated as a displacement relative to the address of the current instruction, which is held in the PC. This exploits the concept of locality, as most memory references in a program are often near the current instruction.

---

Question 7: What is the key difference between preindexing and postindexing as described on page 13?
A. Preindexing updates the register before the memory access, while postindexing updates it after.
B. Preindexing uses a base register, while postindexing uses an index register.
C. Preindexing is used for loads, and postindexing is used for stores.
D. Preindexing performs indexing before indirection, while postindexing performs it after indirection.

Correct Answer: D
Explanation: Page 13 defines the two modes based on when the indexing operation occurs relative to the indirection (accessing the pointer).
- **Preindexing:** EA = (A + (R)). The indexing (A + (R)) happens first to calculate the address of the pointer, and then that location is accessed.
- **Postindexing:** EA = (A) + (R). The indirection ((A)) happens first to get a base address, and then the index register (R) is added to it.

---

Question 8: In the x86 addressing mode calculation shown in Figure 14.2, what are the three components that can be combined to form the "Effective Address"?
A. Base Register, Index Register, and Displacement
B. Segment Register, Base Register, and Index Register
C. Selector, Scale, and Limit
D. Base Address, Linear Address, and Displacement

Correct Answer: A
Explanation: Figure 14.2 on page 15 shows that the Effective Address is calculated by summing the contents of a Base Register, the scaled contents of an Index Register (Index Register * Scale), and a Displacement value from the instruction. This Effective Address is then added to a Segment Base Address to get the final Linear Address.

---

Question 9: Based on the ARM Indexing Methods in Figure 14.3, which instruction will update the base register `r1` with the new address after the memory access?
A. `STRB r0, [r1, #12]`
B. `STRB r0, [r1], #12`
C. `STRB r0, [r1, #12]!`
D. Both B and C

Correct Answer: C
Explanation: Figure 14.3 on page 17 illustrates three ARM indexing methods.
- **(a) Offset:** `STRB r0, [r1, #12]` uses the address `(r1) + 12` but does not modify `r1`.
- **(b) Preindex:** `STRB r0, [r1, #12]!` uses the address `(r1) + 12` and then updates `r1` to this new address. The `!` symbol signifies this "write-back" or update.
- **(c) Postindex:** `STRB r0, [r1], #12` uses the original address in `r1` for the memory access and *then* updates `r1` to `(r1) + 12`.
The question asks which instruction updates the base register with the *new address*, which in the context of the preindex diagram is the calculated effective address. The postindex also updates the register, but after using its original value. However, the preindex `!` syntax is the explicit indicator for updating the register with the calculated address used for the transfer. Both B and C update the register, but C does so with the newly calculated address before the conceptual next step, making it a clear example of updating with the "new address" used in the transfer. Given the common interpretation of this syntax, C is the best answer. To be precise, both B and C update the register, but they do so at different points relative to the memory access. The `!` in pre-indexing is the classic "update" syntax.

---

Question 10: What is the effective address range of a standard ARM branch instruction?
A. ± 16MB from the program counter
B. ± 32MB from the program counter
C. ± 64MB from the program counter
D. The full 32-bit address space

Correct Answer: B
Explanation: As described on page 18, ARM branch instructions use immediate addressing. The instruction contains a 24-bit value. This value is "Shifted 2 bits left so that the address is on a word boundary." A 24-bit value shifted left by 2 bits becomes a 26-bit word-aligned offset. This allows for a range of 2^26 bytes. Since the offset is signed (treated as a two's complement number), the range is ±2^25 bytes, which is ±33,554,432 bytes, or ±32MB, relative to the program counter.

---

Question 11: According to Figure 14.4, an `LDMIA r10!, {r0, r1, r4}` instruction is executed, where `r10` initially contains `0x20C`. Which memory addresses will be read from? (Assume 32-bit words, so each register is 4 bytes).
A. `0x20C`, `0x210`, `0x214`
B. `0x208`, `0x20C`, `0x210`
C. `0x210`, `0x214`, `0x218`
D. `0x20C`, `0x208`, `0x204`

Correct Answer: A
Explanation: The mnemonic `LDMIA` stands for "Load Multiple Increment After". The `IA` part specifies the behavior. According to the diagram for Increment After (IA) on page 19, the transfer starts at the base register's address and the pointer is incremented *after* each transfer. So, the registers {r0, r1, r4} will be loaded from addresses `0x20C`, `0x20C + 4`, and `0x20C + 8`, which corresponds to `0x20C`, `0x210`, and `0x214`.

---

Question 12: Which of the following is NOT a primary design issue that affects or is affected by instruction length, as listed on page 21?
A. The number of floating-point registers
B. Memory size
C. Bus structure
D. Processor speed

Correct Answer: A
Explanation: Page 21 lists several factors that influence instruction length design: Memory size, Memory organization, Bus structure, Processor complexity, and Processor speed. While the number of registers is a factor in bit allocation *within* an instruction (page 22), the number of *floating-point* registers specifically is not listed as a primary driver of the overall instruction length itself, unlike fundamental system characteristics like memory size and bus width.

---

Question 13: In the PDP-8 Memory Reference Instruction format (Figure 14.5), what is the purpose of the `D/I` bit (bit 3)?
A. To select the device for an I/O operation
B. To specify Direct or Indirect addressing
C. To indicate Displacement or Immediate mode
D. To enable or disable interrupts

Correct Answer: B
Explanation: The legend at the bottom of Figure 14.5 on page 23 explicitly states that `D/I = Direct/Indirect address`. This single bit allows the instruction to switch between fetching the operand's address directly from the displacement field or treating the displacement field as a pointer to the operand's address.

---

Question 15: In the VAX instruction `ADDL3 #5, R0, @A[R2]` shown in Figure 14.8, what does the byte `50` represent?
A. The opcode for the ADD operation
B. The short literal value 5
C. An index prefix for register R2
D. The destination operand, specified in register mode as R0

Correct Answer: D
Explanation: Analyzing the example on page 27, the instruction is composed of operand specifiers after the opcode (`C1`). The first operand is `#5` (short literal, `05`). The second operand is `R0`. The hexadecimal value `50` is the operand specifier for this. The '5' in `50` indicates register mode, and the '0' indicates register R0. Therefore, `50` specifies the second operand, which is the value in R0, and is also where the result will be stored (`ADDL3` is a 3-operand instruction).

---

Question 16: In the x86 instruction format (Figure 14.9), what is the function of the SIB (Scale, Index, Base) byte?
A. To specify an immediate operand value.
B. To specify more complex, register-based addressing modes.
C. To override the default segment register.
D. To indicate the size of the operand (16 or 32 bit).

Correct Answer: B
Explanation: As shown in the diagram on page 28, the SIB byte is used when the ModR/M byte alone is not sufficient to describe the addressing mode. The SIB byte allows for addressing modes that involve a scaled index register, such as `[base + index*scale]`. It explicitly defines the Base register, the Index register, and the Scale factor (1, 2, 4, or 8), enabling complex memory operand calculations.

---

Question 17: In the ARM instruction formats shown in Figure 14.10, what is the purpose of the 'S' bit (bit 20) in data processing instructions?
A. To signify that the instruction updates the condition codes.
B. To select a source register.
C. To specify a shift operation.
D. To restrict execution to supervisor mode.

Correct Answer: A
Explanation: The legend at the bottom of Figure 14.10 on page 29 clearly states: "S = For data processing instructions, signifies that the instruction updates the condition codes". For example, an `ADD` instruction will just perform addition, while an `ADDS` instruction will perform the addition and then update the N, Z, C, and V flags in the status register based on the result.

---

Question 18: How does the ARM architecture generate a wide range of 32-bit immediate constants using only a 12-bit field in the instruction?
A. The 12-bit value is sign-extended to 32 bits.
B. The 12-bit value is used as an index into a table of constants in ROM.
C. An 8-bit value is zero-extended to 32 bits and then rotated by an amount specified by a 4-bit field.
D. The 12 bits are combined with the contents of the Program Counter.

Correct Answer: C
Explanation: Page 30 and Figure 14.11 describe the mechanism for generating immediate values in ARM instructions. The 12-bit immediate field is split into a 4-bit rotate amount (`ror`) and an 8-bit immediate value. The 8-bit value is padded with zeros to 32 bits, and then the resulting 32-bit word is rotated right by an amount equal to `2 * ror`. This clever scheme allows the creation of many useful constants (e.g., bitmasks, powers of two) that would otherwise require a full 32-bit field.

---

Question 19: What was the primary motivation for creating the Thumb instruction set for the ARM architecture?
A. To increase processor performance by using 16-bit instructions.
B. To simplify the processor's decode unit.
C. To add new floating-point capabilities.
D. To improve code density for memory-constrained systems.

Correct Answer: D
Explanation: As implied by the discussion on pages 31 and 32, the Thumb instruction set uses 16-bit instructions instead of ARM's standard 32-bit instructions. The main benefit of this is increased code density—more instructions can be stored in the same amount of memory. This was particularly important for early embedded systems with limited memory. Thumb-2 later addressed the performance trade-off, aiming to provide both high density and high performance.

---

Question 20: What major advantage does the Thumb-2 instruction set offer over the previous choice between ARM and Thumb ISAs?
A. It provides high code density comparable to Thumb and performance associated with the ARM ISA.
B. It is a pure 64-bit architecture, superseding both ARM and Thumb.
C. It eliminates the need for a register file, simplifying the design.
D. It only supports immediate addressing, making all instructions faster.

Correct Answer: A
Explanation: Page 32 explicitly states that Thumb-2 "Delivers overall code density comparable with Thumb, together with the performance levels associated with the ARM ISA." Before Thumb-2, developers had to make a trade-off: choose the 16-bit Thumb for its small code size (density) or the 32-bit ARM for its higher performance and functionality. Thumb-2, by mixing 16-bit and 32-bit instructions, offers the best of both worlds.

---

Question 22: Stack addressing is considered a form of which other addressing type?
A. Direct addressing
B. Immediate addressing
C. Index addressing
D. Implied addressing

Correct Answer: D
Explanation: Page 14 states that stack addressing "is a form of implied addressing." This is because the machine instructions that operate on the stack (like `PUSH` or `POP`) do not need to include an explicit memory address or register field for the operand. The operand is implicitly the location at the top of the stack, which is managed by the stack pointer register.

---

Question 24: In the context of bit allocation within an instruction, what is the trade-off associated with having more opcodes?
A. It requires a faster processor clock speed.
B. It reduces the number of general-purpose registers that can be supported.
C. It leaves fewer bits available for addressing.
D. It simplifies the instruction decoding logic.

Correct Answer: C
Explanation: Instruction length is fixed (or has a fixed set of lengths). The bits within an instruction must be allocated among various fields, such as the opcode, addressing mode specifiers, register specifiers, and address/operand fields. This is a zero-sum game. As described on page 22, if you allocate more bits to the opcode to support a larger number of different instructions, you have fewer bits remaining for other purposes, such as specifying memory addresses or immediate operands. This could limit the address range or the magnitude of immediate values.

---

Question 25: A processor has a word length of 32 bits and a word-addressable memory of 2^24 words. An instruction is 32 bits long and includes a 5-bit opcode. In a direct addressing instruction, how many bits are available for the address field?
A. 5
B. 24
C. 32
D. 27

Correct Answer: D
Explanation: This question combines concepts from the entire chapter.
- The instruction length is 32 bits.
- The opcode uses 5 of these bits.
- The remaining bits are available for the address field in a simple direct addressing instruction.
- Calculation: 32 bits (total) - 5 bits (opcode) = 27 bits.
The memory size of 2^24 words is relevant context, as the 27-bit address field is more than sufficient to address any location in this memory (it can address up to 2^27 words).

---

Question 26: Based on Table 14.2 (x86 Addressing Modes), what is the formula for calculating the linear address (LA) in "Base with Scaled Index and Displacement" mode?
A. `LA = (SR) + (B) + (I) + A`
B. `LA = (SR) + (I) × S + (B) + A`
C. `LA = (SR) + (B) + A`
D. `LA = (PC) + A`

Correct Answer: B
Explanation: The table on page 16 provides the algorithms for various x86 addressing modes. The row for "Base with Scaled Index and Displacement" explicitly gives the algorithm as `LA = (SR) + (I) × S + (B) + A`. This is the most complex form shown, combining a segment base, a base register, a scaled index register, and a displacement.

---

Question 27: Which of the following is a key component that an instruction format must define?
A. The layout of the bits of an instruction in terms of its constituent fields.
B. The clock speed at which the instruction will execute.
C. The number of pipeline stages in the processor.
D. The physical location of the instruction in the cache.

Correct Answer: A
Explanation: Page 20 defines instruction formats as follows: "Define the layout of the bits of an instruction, in terms of its constituent fields." This includes specifying which bits are the opcode, which bits define the operands, addressing modes, etc. The other options are related to processor design and execution but are not part of the static definition of an instruction format.

---

Question 28: Comparing Indirect Addressing (EA = (A)) and Register Indirect Addressing (EA = (R)), what is the main performance difference?
A. Indirect addressing can access a larger address space.
B. Register indirect addressing requires one less memory reference.
C. Indirect addressing is simpler for the processor to decode.
D. Register indirect addressing cannot be used with displacement.

Correct Answer: B
Explanation: As explained on page 9, Register Indirect Addressing "uses one less memory reference than indirect addressing." In standard Indirect Addressing, the first memory access fetches the pointer (the effective address) from memory location A. In Register Indirect Addressing, the pointer is already in register R, so the first memory access is eliminated. The processor goes directly to memory using the address in R.

---

Question 29: What is a defining characteristic of Base-Register Addressing?
A. The referenced register contains a main memory address, and the instruction's address field contains a displacement from that address.
B. The referenced register contains a displacement, and the instruction's address field contains a main memory address.
C. It is only used for branching instructions relative to the Program Counter.
D. The base register is always implicitly the Stack Pointer.

Correct Answer: A
Explanation: Page 12 defines Base-Register Addressing as a mode where "The referenced register contains a main memory address and the address field contains a displacement from that address." This is particularly useful for segmentation, where the register holds the base address of a data segment and the displacement points to a specific item within that segment. This is distinct from indexing where the roles are often conceptually reversed.

---

Question 30: What is the purpose of the condition code field (`cond`) in most 32-bit ARM instructions?
A. To specify the condition of the carry flag.
B. To define the length of the instruction.
C. To allow an instruction to execute conditionally based on the processor status flags.
D. To distinguish between a data processing and a load/store instruction.

Correct Answer: C
Explanation: The ARM instruction format diagram on page 29 shows a 4-bit `cond` field at the beginning of many instruction types. This field allows almost every ARM instruction to be executed conditionally. For example, an instruction can be set to execute only if the result of a previous operation was zero (the Z flag is set). This powerful feature can reduce the need for short branch instructions. The Thumb-2 ISA introduced the `IT` instruction to provide similar functionality in a different way.
Question 31: According to the PDP-11 instruction formats on page 26, how are the source and destination operands specified in a standard two-operand instruction like the one labeled as format '1'?
A. They are specified by a 6-bit memory address each.
B. They are specified by an 8-bit opcode followed by two 4-bit register numbers.
C. Each is specified by a 6-bit field containing a 3-bit addressing mode and a 3-bit register number.
D. The source is specified by a 6-bit field, but the destination is always an implicit accumulator.

Correct Answer: C
Explanation: The notes below Figure 14.7 on page 26 state: "Source and Destination each contain a 3-bit addressing mode field and a 3-bit register number". This means that each of the 6-bit operand fields is powerful enough to specify not only which of the 8 general-purpose registers to use but also *how* to use it (e.g., as a direct value, as a pointer, with auto-increment, etc.), making the PDP-11 instruction set very flexible.

---

Question 32: In the ARM Load/Store Multiple Addressing diagram (Figure 14.4), consider an STMDB r10!, {r0, r1, r4} instruction where r10 initially holds 0x20C. At which memory address will the contents of register r4 be stored?
A. 0x20C
B. 0x208
C. 0x204
D. 0x200
Correct Answer: B
Explanation: The mnemonic STMDB stands for "Store Multiple Decrement Before". This operation follows two key rules:
Decrement Before: The address in the base register (r10) is decremented before each 4-byte register is stored.
ARM Convention: Irrespective of the addressing mode, the registers are stored such that the lowest-numbered register in the list (r0) is written to the lowest memory address, and the highest-numbered register (r4) is written to the highest memory address.
The instruction will store three registers, using addresses 0x208 (0x20C - 4), 0x204 (0x20C - 8), and 0x200 (0x20C - 12).
Following the ARM convention:
r0 (lowest number) is stored at 0x200 (lowest address).
r1 is stored at 0x204.
r4 (highest number) is stored at 0x208 (highest address).
This is consistent with the diagram for "Decrement before (DB)" on page 19, which shows the final state of memory with (r4) at address 0x208.
---

Question 33: Based on the VAX instruction example on page 27, what is the function of the instruction `MOVW 356(R4), 25(R11)`?
A. Move a word from register R4 to register R11, using 356 and 25 as status flags.
B. Move a word from the memory address calculated by `(R4) + 356` to the memory address calculated by `(R11) + 25`.
C. Move the 16-bit value `356` into the memory address `(R11) + 25`, using R4 as an index.
D. Add the contents of memory at `(R4) + 356` and `(R11) + 25` and store the result in R4.

Correct Answer: B
Explanation: The description provided on page 27 for this instruction is: "Move a word from address that is 356 plus contents of R4 to address that is 25 plus contents of R11". This is a memory-to-memory move operation. The notation `offset(Register)` is a standard assembly representation for displacement addressing, where the effective address is `EA = offset + (Register)`. `MOVW` stands for "Move Word". The first operand is the source, and the second is the destination.

---

Question 34: In the full x86 instruction format shown on page 28, what is the purpose of the optional prefix bytes like "Segment override"?
A. To increase the value of the immediate operand.
B. To specify the instruction is part of a 64-bit extension.
C. To change the default behavior of the instruction, such as using a non-default segment register for a memory access.
D. To tell the processor to halt after the instruction completes.

Correct Answer: C
Explanation: The diagram on page 28 shows several optional prefix bytes at the beginning of an x86 instruction. The "Segment override" prefix, for example, allows the programmer to specify that a memory access should use a different segment register (e.g., ES, FS, GS) than the default one for that particular instruction (e.g., DS or SS). Other prefixes like "Operand size override" can switch between 16-bit and 32-bit operations, modifying the instruction's default behavior.

---

Question 35: In the PDP-8 Register Reference Instructions (Figure 14.5), how are multiple operations like CLA (Clear Accumulator) and CMA (Complement Accumulator) combined in one instruction?
A. Each operation has its own separate instruction word.
B. Bits in a single instruction word are used as flags, allowing multiple compatible operations to be specified and executed in sequence within one instruction cycle.
C. The processor automatically combines sequential CLA and CMA instructions into a single micro-op.
D. A 3-bit field selects one of eight possible combined operations.

Correct Answer: B
Explanation: The PDP-8 used a clever encoding for its "microprogrammed" register reference instructions. As shown in the "Group 1 Microinstructions" format on page 23, a single instruction word has individual bits dedicated to specific operations (CLA, CLL, CMA, CML, etc.). If a bit is set to 1, that operation is performed. This allowed programmers to set multiple bits to perform several simple register operations in a single instruction, saving memory and time. For example, the instruction `CLA CMA` would be a single instruction word with both the CLA and CMA bits set.

---

Question 38: What functionality does the `IT` (If-Then) instruction add to the Thumb-2 instruction set?
A. It allows for the conditional execution of a block of subsequent instructions without using traditional branches.
B. It provides a way to perform 32-bit integer arithmetic.
C. It allows an instruction to access a table of immediate values.
D. It initiates a trap to the operating system for interrupt handling.

Correct Answer: A
Explanation: As mentioned on page 32, the Thumb-2 instruction set "Introduces a new If-Then (IT) instruction that delivers much of the functionality of the condition field in ARM instructions." The `IT` instruction makes the next one to four instructions conditional. For example, `ITTE EQ` would mean "If Equal, Then execute the next instruction, Then execute the one after that, Else execute the third instruction." This provides a very efficient way to write short conditional blocks of code, improving both performance and code density over using branches.

---

Question 39: In the ARM load/store instruction format (page 29), what is the function of the L bit (bit 20)?
A. It indicates that a Long value (64-bit) should be transferred.
B. It distinguishes between a Load (L=1) and a Store (L=0) operation.
C. It signifies that the address should be loaded into the Link Register.
D. It enables a legacy addressing mode for older ARM cores.

Correct Answer: B
Explanation: The legend at the bottom of page 29 explains the meaning of the various flag bits. For load/store instructions, "L = For load/store instructions, distinguishes between a Load (L==1) and a Store (L==0)". This single bit in the opcode field allows the same basic instruction format to be used for both moving data from memory to a register (Load) and from a register to memory (Store).

---

Question 40: In the expansion of the Thumb instruction `ADD r3, #19` to its 32-bit ARM equivalent `ADDS r3, r3, #19` (Figure 14.12), why is the `rotate` field in the ARM instruction set to zero?
A. A zero rotation is required for all ADD instructions.
B. The immediate value 19 can be represented directly within an 8-bit field, so no rotation is needed.
C. The Thumb instruction set does not support rotated immediates.
D. The rotate field is used to hold the source register, which is also `r3`.

Correct Answer: B
Explanation: The ARM immediate encoding scheme (page 30) uses an 8-bit value and a 4-bit rotate. The goal is to represent the desired immediate constant. The value 19 (or `0x13`) fits entirely within the 8-bit immediate field (bits 0-7 of the expanded instruction). Therefore, no rotation is necessary to generate the value. The 4-bit `rotate` field (bits 8-11) is set to `0000`, which corresponds to a rotation of zero.

---

Question 41: What is the primary difference between a CISC (Complex Instruction Set Computer) and a RISC (Reduced Instruction Set Computer) philosophy regarding instruction formats and addressing?
A. CISC processors always use variable-length instructions and many addressing modes, while RISC processors use fixed-length instructions and fewer, simpler addressing modes.
B. RISC processors do not have a memory addressing mode; all operands must be in registers.
C. CISC processors are always faster than RISC processors because their instructions do more work.
D. RISC instructions are always 16-bit, while CISC instructions are always 32-bit.

Correct Answer: A
Explanation: While not explicitly stated as a direct comparison, the chapter's examples illustrate this key difference. Architectures like the VAX and x86 (classic CISC examples on pages 27-28) feature numerous complex addressing modes and highly variable instruction lengths. In contrast, architectures like ARM (a classic RISC example on pages 29-31) have more regular, fixed-length (or dual-length with Thumb-2) instructions and a more constrained "load/store" architecture where complex memory operations are broken down into simpler, explicit steps. This simplifies processor design, especially pipelining, which is a core tenet of RISC.

---

Question 42: A computer uses 16-bit instructions and 16-bit memory words. The instruction format provides 4 bits for the opcode, and the rest for an address. What is the maximum number of directly addressable memory words?
A. 16 words
B. 4096 words
C. 65,536 words
D. 12 words

Correct Answer: B
Explanation: This is a calculation question based on instruction format principles.
- Total instruction length = 16 bits.
- Opcode length = 4 bits.
- Bits available for address = 16 - 4 = 12 bits.
With 12 bits for the address field, the number of unique memory locations (words, in this case) that can be directly addressed is 2 raised to the power of the number of address bits.
- Maximum addressable words = 2^12 = 4096 words.
Question 43: How does the typical use of Base-Register addressing conceptually differ from Indexing, given that the effective address calculation can be the same?
A. Base-register addressing is only for read operations, while indexing is for both read and write.
B. In base-register addressing the register holds a displacement and A is an address, while in indexing the register holds an address and A is a displacement.
C. In base-register addressing, the register holds a main memory base address and A is a small displacement; in indexing, A is typically a base memory address and the register holds a variable displacement (the index).
D. Base-register addressing is used by the operating system, while indexing is used by user programs.

Correct Answer: C
Explanation: Pages 12 and 13 describe the subtle but important conceptual difference. Although both can use the formula EA = A + (R), their common usage differs. In Base-Register addressing, the register (R) holds a pointer to a base address (e.g., the start of a program module or data segment), and the instruction's address part (A) is a small offset within that segment. This is useful for memory segmentation and relocation. In Indexing, the instruction's address part (A) often holds the base address of a data structure (like an array), and the register (R) holds a variable index that is used to step through the elements of that structure.

Question 44: An ARM branch instruction contains the 24-bit immediate value 0x00000A. What is the resulting byte offset that will be added to the program counter?
A. +10 bytes
B. +20 bytes
C. +40 bytes
D. +16 bytes

Correct Answer: C
Explanation: As stated on page 18, the 24-bit value in an ARM branch instruction is "Shifted 2 bits left so that the address is on a word boundary." A left shift by 2 bits is equivalent to multiplying by 4.

The immediate value is 0x00000A, which is 10 in decimal.

The byte offset is calculated as 10 * 4 = 40 bytes.
This offset is then added to the program counter to determine the branch target address.

Question 45: In the PDP-8 Memory Reference Instruction format shown in Figure 14.5, what is the purpose of the Z/C bit?
A. It indicates whether to skip on a Zero or Carry condition.
B. It selects whether the displacement is relative to memory page 0 or the current memory page.
C. It determines if the accumulator should be cleared after the operation.
D. It specifies whether the operand is a character or a numeric value.

Correct Answer: B
Explanation: The legend at the bottom of Figure 14.5 on page 23 defines the Z/C bit as "Page 0 or Current page". The PDP-8 had a 4K-word memory space, which was divided into 32 pages of 128 words each. This bit allowed a memory reference instruction to access either the base page (page 0) or the page where the instruction itself was located (the current page), which was a memory management feature to work around the limited address field size.

Question 46: In the ARM load/store instruction formats shown in Figure 14.10, what is the role of the P, U, and W bits?
A. They define the Priority, User-mode access, and Wait-states for the memory operation.
B. They specify the details of the addressing mode, such as pre- vs. post-indexing, up vs. down offset, and whether to write back the new address to the base register.
C. They indicate whether the operand is Packed, Unsigned, or a Word.
D. They select which part of the processor (Pipeline, ALU, Write-buffer) should handle the instruction.

Correct Answer: B
Explanation: The legend at the bottom of page 29 states: "P, U, W = bits that distinguish among different types of addressing_mode". These bits are crucial for defining the behavior of ARM's powerful load/store addressing modes.

P (Pre/Post): Distinguishes between pre-indexed (offset is added before memory access) and post-indexed (offset is added after).

U (Up/Down): Indicates whether the offset is added to (Up) or subtracted from (Down) the base register.

W (Write-back): Controls whether the final calculated address is written back into the base register.

Question 47: According to the description on page 14, references to stack locations in memory are technically implemented as which type of addressing?
A. Direct addressing
B. Index addressing
C. Register indirect addressing
D. Immediate addressing

Correct Answer: C
Explanation: Page 14 explains that "Associated with the stack is a pointer whose value is the address of the top of the stack." It continues, "The stack pointer is maintained in a register. Thus references to stack locations in memory are in fact register indirect addresses." Even though stack instructions like PUSH and POP are a form of implied addressing (the operand location is implicit), the underlying mechanism used by the hardware to access that memory location is register indirect addressing via the stack pointer register.

Question 48: What is the principal disadvantage of Stack addressing as listed in Table 14.1?
A. Multiple memory references
B. Limited address space
C. Limited applicability
D. High complexity

Correct Answer: C
Explanation: Table 14.1 on page 4 summarizes the basic addressing modes. For Stack addressing, the "Principal Disadvantage" is listed as "Limited applicability." While a stack is extremely efficient for specific tasks like managing procedure calls and evaluating arithmetic expressions, it is not a flexible, general-purpose mechanism for accessing random data structures in memory in the way that modes like indexing or displacement are.

Question 49: An ARM data processing instruction needs to generate an immediate constant. The 4-bit rotate field is 0100 and the 8-bit immediate field is 0xFF. What is the final 32-bit immediate value?
A. 0x0000FF00
B. 0xFF000000
C. 0x00FF0000
D. 0x000000FF

Correct Answer: B
Explanation: This question tests the ARM immediate constant generation mechanism described on page 30.

The 8-bit immediate value 0xFF is zero-extended to 32 bits, resulting in 0x000000FF.

The 4-bit rotate field 0100 has a decimal value of 4.

The rotation amount is twice the value of the rotate field: 2 * 4 = 8 bits.

The operation is a rotate right (ror).

Rotating 0x000000FF right by 8 bits moves the FF from the least significant byte position to the most significant byte position. The result is 0xFF000000.

Question 50: In the x86 instruction format (Figure 14.9), the ModR/M byte is central to specifying operands. What information is provided by the Mod (Mode) field within this byte?
A. It specifies the scale factor (1, 2, 4, or 8) for the index register.
B. It works with the R/M field to specify whether an operand is in a register or in memory and, if in memory, the size of the displacement field.
C. It indicates if the operation is a modification of a register or a memory location.
D. It selects one of four possible segment registers to override the default.

Correct Answer: B
Explanation: The Mod field (bits 7-6) of the ModR/M byte is critical for decoding the operand. Its primary role is to specify how the R/M (Register/Memory) field is to be interpreted.

If Mod is 11, the R/M field specifies a register operand.

If Mod is 00, 01, or 10, the R/M field specifies a memory addressing mode. The Mod value itself then indicates the size of the displacement that follows: 00 (no displacement, unless R/M=101), 01 (8-bit displacement), or 10 (16/32-bit displacement). This is shown in the detailed breakdown on page 28.

---


## Instruction Formats and Length


---

Question 14: What is the main disadvantage of using variable-length instructions?
A. They are less memory-efficient.
B. They cannot support a large number of addressing modes.
C. They increase the complexity of the processor.
D. They require all instructions to be fetched from a cache.

Correct Answer: C
Explanation: Page 25 explicitly states that variable-length instructions "Increase the complexity of the processor." The processor's decode unit must first determine the length of the current instruction before it can fetch the next one, which complicates instruction fetching and pipelining. A common strategy to mitigate this is to fetch a block of bytes large enough to hold the longest possible instruction, but this adds its own complexity.

---

Question 21: According to the Thumb-2 encoding diagram (Figure 14.13), how does the processor determine that an instruction is a 32-bit Thumb-2 instruction?
A. The first halfword [15:13] is `111` and the next halfword starts with `00`.
B. The first halfword bits [15:13] are `111` and bits [12:11] are *not* `00`.
C. The first halfword bits [15:13] are `not 111`.
D. The instruction is always 32 bits unless it is a branch.

Correct Answer: B
Explanation: The table in Figure 14.13 on page 33 provides the decoding rules. For an instruction to be a 32-bit Thumb-2 instruction, two conditions must be met in the first 16-bit halfword:
1.  Bits [15:13] must be `111`.
2.  Bits [12:11] must be something other than `00`.
If bits [12:11] were `00`, it would be a 16-bit unconditional branch instruction (if bit 13 is also 1, as part of the 111 pattern). If bits [15:13] were not `111`, it would be a standard 16-bit Thumb instruction.

---

Question 23: In the PDP-10 Instruction Format (Figure 14.6), how many bits are allocated for the main memory address?
A. 18 bits
B. 36 bits
C. 9 bits
D. 4 bits

Correct Answer: A
Explanation: The diagram on page 24 clearly shows the fields of the 36-bit PDP-10 instruction format. The "Memory Address" field occupies bits 18 through 35, inclusive. This is a total of 35 - 18 + 1 = 18 bits.

---

Question 36: What does the term "address granularity" refer to in the context of instruction set design?
A. The number of different addressing modes available.
B. The trade-off between register and memory operands.
C. The fundamental unit of memory that can be addressed by an instruction, e.g., byte vs. word.
D. The physical size of the address bus.

Correct Answer: C
Explanation: Address granularity, a key design choice mentioned on page 22, refers to the size of the memory unit that a single address points to. In a byte-addressable machine, each unique address refers to a single byte. In a word-addressable machine, each address refers to a multi-byte word (e.g., 16-bit or 32-bit). This choice impacts the instruction set design (e.g., needing instructions like Load Byte, Load Word) and the maximum amount of memory that can be addressed with a given number of address bits.

---

Question 37: When a processor encounters variable-length instructions, what is a typical strategy for instruction fetching, as described on page 25?
A. Fetch one byte at a time and decode it to determine the instruction length.
B. Fetch a fixed-size block of bytes or words that is equal to or greater than the longest possible instruction.
C. Only allow variable-length instructions if they are aligned to a 16-byte cache line boundary.
D. Read the first two bits of every instruction, which always encode the length.

Correct Answer: B
Explanation: Page 25 states: "Because the processor does not know the length of the next instruction to be fetched a typical strategy is to fetch a number of bytes or words equal to at least the longest possible instruction." The processor fetches a "chunk" of the instruction stream into a prefetch buffer. The decode logic then processes the instructions from this buffer, figuring out where one ends and the next begins. This avoids a slow, byte-by-byte fetch-and-decode cycle.