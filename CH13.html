<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Instruction Sets Review Quiz</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .stats {
            background: #f8f9fa;
            padding: 20px;
            text-align: center;
            border-bottom: 2px solid #e9ecef;
        }

        .stat-item {
            display: inline-block;
            margin: 0 20px;
            padding: 10px 20px;
            background: white;
            border-radius: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 40px;
        }

        .section-title {
            font-size: 1.8em;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #e74c3c;
        }

        .question {
            background: #f8f9fa;
            margin-bottom: 25px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            transition: transform 0.3s ease;
        }

        .question:hover {
            transform: translateY(-2px);
        }

        .question-header {
            background: #e74c3c;
            color: white;
            padding: 15px 20px;
            font-weight: bold;
            font-size: 1.1em;
        }

        .question-content {
            padding: 20px;
        }

        .question-text {
            font-size: 1.1em;
            margin-bottom: 15px;
            font-weight: 500;
        }

        .options {
            list-style: none;
        }

        .option {
            margin-bottom: 10px;
        }

        .option label {
            display: block;
            padding: 12px 20px;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .option label:hover {
            border-color: #e74c3c;
            background: #fff5f5;
        }

        .option input[type="radio"] {
            margin-right: 10px;
        }

        .option.correct label {
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
        }

        .option.incorrect label {
            background: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }

        .explanation {
            margin-top: 15px;
            padding: 15px;
            background: #ffebee;
            border-left: 4px solid #e74c3c;
            border-radius: 5px;
            display: none;
        }

        .explanation.show {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .explanation strong {
            color: #2c3e50;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #c0392b);
            width: 0%;
            transition: width 0.5s ease;
        }

        .final-stats {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            margin-top: 30px;
            display: none;
        }

        .final-stats.show {
            display: block;
            animation: slideUp 0.5s ease;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .final-stats h2 {
            font-size: 2em;
            margin-bottom: 20px;
        }

        .final-score {
            font-size: 3em;
            font-weight: bold;
            margin: 20px 0;
        }

        .restart-btn {
            background: white;
            color: #28a745;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .restart-btn:hover {
            transform: scale(1.05);
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .content {
                padding: 20px;
            }
            
            .stat-item {
                display: block;
                margin: 10px 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📋 Instruction Sets Review Quiz</h1>
            <p>Test your knowledge of processor instruction sets and machine architecture</p>
        </div>

        <div class="stats">
            <div class="stat-item">
                <strong>Progress:</strong> <span id="progress">0/40</span>
            </div>
            <div class="stat-item">
                <strong>Correct:</strong> <span id="correct">0</span>
            </div>
            <div class="stat-item">
                <strong>Incorrect:</strong> <span id="incorrect">0</span>
            </div>
            <div class="stat-item">
                <strong>Score:</strong> <span id="score">0%</span>
            </div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="content" id="quizContent">
            <!-- Quiz content will be generated by JavaScript -->
        </div>

        <div class="final-stats" id="finalStats">
            <h2>🎉 Quiz Complete!</h2>
            <div class="final-score" id="finalScore">0%</div>
            <p id="finalMessage">Great job completing the quiz!</p>
            <button class="restart-btn" onclick="restartQuiz()">Take Quiz Again</button>
        </div>
    </div>

    <script>
        const quizData = [
            {
                section: "Instruction Fundamentals and Formats",
                questions: [
                    {
                        id: 1,
                        text: "What is the collection of different instructions that a processor can execute called?",
                        options: [
                            "A computer program",
                            "The processor's instruction set",
                            "Machine instructions",
                            "An opcode list"
                        ],
                        correct: 1,
                        explanation: "Page 2 of the presentation defines the processor's instruction set as \"The collection of different instructions that the processor can execute.\" Options A, C, and D are related concepts but do not accurately define the entire collection of executable instructions."
                    },
                    {
                        id: 2,
                        text: "According to the Instruction Cycle State Diagram in Figure 13.1, what is the initial state of the instruction cycle?",
                        options: [
                            "Instruction address calculation",
                            "Instruction fetch",
                            "Data Operation",
                            "Instruction operation decoding"
                        ],
                        correct: 0,
                        explanation: "The diagram on page 3 shows that the cycle begins with \"Instruction address calculation\" to determine the address of the instruction to be executed next. This is followed by \"Instruction fetch,\" where the instruction is retrieved from that address."
                    },
                    {
                        id: 3,
                        text: "Which of the four areas for operands must supply a main or virtual memory address for reference?",
                        options: [
                            "Main or virtual memory",
                            "I/O device",
                            "Processor register",
                            "Immediate"
                        ],
                        correct: 0,
                        explanation: "Page 4, point 1, states that for \"Main or virtual memory\" operands, \"the main or virtual memory address must be supplied.\" The other options refer to different ways of locating or specifying an operand."
                    },
                    {
                        id: 4,
                        text: "In the simple 16-bit instruction format shown in Figure 13.2, how many distinct operations can be specified by the opcode field?",
                        options: [
                            "4",
                            "16",
                            "32",
                            "64"
                        ],
                        correct: 1,
                        explanation: "The diagram on page 5 shows the opcode field is 4 bits long. The number of unique combinations possible with a 4-bit field is 2 to the power of 4 (2^4), which equals 16. Therefore, up to 16 different operations can be specified."
                    },
                    {
                        id: 5,
                        text: "In instruction representation, what do abbreviations like ADD, SUB, and LOAD represent?",
                        options: [
                            "Operands",
                            "Opcodes (mnemonics)",
                            "Memory addresses",
                            "Data types"
                        ],
                        correct: 1,
                        explanation: "Page 6 explains that opcodes (the part of an instruction that specifies the operation to be performed) are represented by abbreviations called \"mnemonics\" for ease of programming."
                    },
                    {
                        id: 6,
                        text: "Which category of instruction types is used to test the value of a data word or to branch to a different set of instructions?",
                        options: [
                            "Data processing",
                            "Data movement",
                            "Data storage",
                            "Control"
                        ],
                        correct: 3,
                        explanation: "The diagram on page 7 describes \"Control\" instructions. It explicitly states that \"Test instructions are used to test the value of a data word...\" and \"Branch instructions are used to branch to a different set of instructions...\"."
                    },
                    {
                        id: 7,
                        text: "Based on the program examples for Y = (A-B) / (C+(D*E)) in Figure 13.3, which instruction type generally requires the fewest instructions to perform the calculation?",
                        options: [
                            "Three-address instructions",
                            "Two-address instructions",
                            "One-address instructions",
                            "Zero-address instructions"
                        ],
                        correct: 0,
                        explanation: "Figure 13.3 on page 8 shows the three-address version using 4 instructions, the two-address version using 6 instructions, and the one-address version using 8 instructions. Therefore, for this specific problem, the three-address format is the most compact in terms of the number of instructions."
                    },
                    {
                        id: 8,
                        text: "According to Table 13.1, how is a one-address instruction like \"OP A\" typically interpreted in a machine with an accumulator?",
                        options: [
                            "A <- B OP C",
                            "A <- A OP B",
                            "T <- (T-1) OP T",
                            "AC <- AC OP A"
                        ],
                        correct: 3,
                        explanation: "Table 13.1 on page 9 shows the interpretation of instructions based on the number of addresses. For a one-address instruction \"OP A,\" the interpretation is `AC <- AC OP A`, where AC is an implicit operand, the accumulator."
                    },
                    {
                        id: 9,
                        text: "Which fundamental design issue of an instruction set deals with \"The mode or modes by which the address of an operand is specified\"?",
                        options: [
                            "Operation repertoire",
                            "Data types",
                            "Instruction format",
                            "Addressing"
                        ],
                        correct: 3,
                        explanation: "On page 10, under the list of \"Fundamental design issues,\" the \"Addressing\" issue is defined as \"The mode or modes by which the address of an operand is specified.\""
                    },
                    {
                        id: 10,
                        text: "What is the \"packed decimal\" representation of numbers?",
                        options: [
                            "Each decimal digit is represented by an 8-bit ASCII code.",
                            "Each decimal digit is represented by a 4-bit code, with two digits stored per byte.",
                            "A 32-bit or 64-bit binary floating-point number.",
                            "An unsigned binary integer."
                        ],
                        correct: 1,
                        explanation: "Page 12 defines packed decimal representation as a method where \"Each decimal digit is represented by a 4-bit code with two digits stored per byte.\" This is an efficient way to store decimal numbers for business applications."
                    }
                ]
            },
            {
                section: "Data Types and Character Representation",
                questions: [
                    {
                        id: 11,
                        text: "In the United States, the International Reference Alphabet (IRA) is more commonly known by what name?",
                        options: [
                            "EBCDIC",
                            "ASCII",
                            "Unicode",
                            "Packed Decimal"
                        ],
                        correct: 1,
                        explanation: "Page 13 states that the \"most commonly used character code is the International Reference Alphabet (IRA)\" and that it is \"Referred to in the United States as the American Standard Code for Information Interchange (ASCII)\"."
                    },
                    {
                        id: 12,
                        text: "One advantage of a bit-oriented view of data is the ability to manipulate individual bits. Which of the following is given as an example of this manipulation?",
                        options: [
                            "Storing Boolean arrays efficiently.",
                            "Performing character string comparisons.",
                            "Shifting significant bits for software-implemented floating-point operations.",
                            "Executing system control instructions."
                        ],
                        correct: 2,
                        explanation: "Page 14 lists two examples under the advantage \"To manipulate the bits of a data item.\" The first is: \"If floating-point operations are implemented in software, we need to be able to shift significant bits in some operations.\" Option A is listed as a separate advantage of the bit-oriented view, not an example of bit manipulation itself."
                    },
                    {
                        id: 13,
                        text: "In the x86 architecture, a \"Far pointer\" is a logical address used for memory references in a segmented memory model. What does it consist of?",
                        options: [
                            "A 64-bit effective address only.",
                            "A 16-bit segment selector and an offset of 16, 32, or 64 bits.",
                            "An unsigned integer in a doubleword.",
                            "A packed representation of two BCD digits."
                        ],
                        correct: 1,
                        explanation: "Table 13.2 on page 15 provides definitions for x86 data types. \"Far pointer\" is defined as \"A logical address consisting of a 16-bit segment selector and an offset of 16, 32, or 64 bits.\""
                    },
                    {
                        id: 14,
                        text: "According to the x86 Numeric Data Formats in Figure 13.4, what is the total size of a \"Double extended precision floating point\" number?",
                        options: [
                            "32 bits",
                            "64 bits",
                            "80 bits",
                            "128 bits"
                        ],
                        correct: 2,
                        explanation: "The diagram for \"Double extended precision floating point\" on page 16 shows the bits are numbered from 79 down to 0, which constitutes a total of 80 bits."
                    },
                    {
                        id: 15,
                        text: "MMX and SSE are extensions to the x86 instruction set. What do these acronyms stand for?",
                        options: [
                            "Multimedia Extensions and Standard SIMD Extensions",
                            "Multimedia Extensions and Streaming SIMD Extensions",
                            "Multiple-Mode Extensions and Secure SIMD Extensions",
                            "Mainframe Mapped Extensions and System Streaming Extensions"
                        ],
                        correct: 1,
                        explanation: "Page 17 introduces these extensions and explicitly defines them as \"MMX (multimedia extensions) and SSE (streaming SIMD extensions)\". They were designed to optimize performance for multimedia tasks."
                    },
                    {
                        id: 16,
                        text: "ARM processors support data types of 8 (byte), 16 (halfword), and 32 (word) bits. For which of these types can an unsigned, non-negative integer interpretation be supported?",
                        options: [
                            "Only 32-bit words.",
                            "Only 8-bit bytes and 16-bit halfwords.",
                            "None, ARM only supports signed integers.",
                            "For all three data types."
                        ],
                        correct: 3,
                        explanation: "Page 18 contains a box that explicitly states: \"For all three data types an unsigned interpretation is supported in which the value represents an unsigned, nonnegative integer.\""
                    },
                    {
                        id: 17,
                        text: "In ARM's Endian support (Figure 13.5), what does a program status register E-bit value of 0 signify?",
                        options: [
                            "Little-endian mode",
                            "Big-endian mode",
                            "Unaligned access is enabled",
                            "The processor is in a privileged state"
                        ],
                        correct: 0,
                        explanation: "Figure 13.5 shows two diagrams. The one on the left is labeled \"program status register E-bit = 0.\" In this diagram, Byte 0 from memory (the lowest address) is loaded into the lowest byte of the register (bits 0-7), which is the characteristic behavior of little-endian byte ordering."
                    },
                    {
                        id: 18,
                        text: "In the x86 single-precision floating-point format shown in Figure 13.4, how many bits are used for the significand (mantissa)?",
                        options: [
                            "1",
                            "8",
                            "23",
                            "31"
                        ],
                        correct: 2,
                        explanation: "The diagram for \"Single precision floating point\" on page 16 shows the total format is 32 bits. The `significand` field occupies bits 0 through 22. The total number of bits is calculated as (22 - 0 + 1), which equals 23 bits."
                    },
                    {
                        id: 19,
                        text: "What type of operand is contained directly within a field of the instruction being executed?",
                        options: [
                            "A processor register",
                            "A memory operand",
                            "An I/O operand",
                            "An immediate operand"
                        ],
                        correct: 3,
                        explanation: "Page 4 defines an \"Immediate\" operand as one where \"The value of the operand is contained in a field in the instruction being executed.\" This avoids an extra memory fetch to get the operand's value."
                    },
                    {
                        id: 20,
                        text: "In the x86 instruction set, which instruction adds 1 to the destination operand while preserving the state of the CF (Carry) flag?",
                        options: [
                            "ADD Dest, 1",
                            "INC Op",
                            "ADC Op",
                            "NEG Op"
                        ],
                        correct: 1,
                        explanation: "Table 13.3 on page 20 describes the `INC Op` instruction as \"Adds 1 to the destination operand, while preserving the state of the CF flag.\" This is different from a standard `ADD` which would modify the carry flag."
                    }
                ]
            },
            {
                section: "Instruction Set Operations and Logical Operations",
                questions: [
                    {
                        id: 21,
                        text: "What is the key difference between the `SHR` (Shift Logical Right) and `SAR` (Shift Arithmetic Right) instructions in the x86 instruction set?",
                        options: [
                            "`SHR` preserves the sign bit, while `SAR` does not.",
                            "`SAR` preserves the sign bit, while `SHR` fills empty positions with zeros.",
                            "`SHR` is for signed integers, and `SAR` is for unsigned integers.",
                            "There is no functional difference; they are aliases."
                        ],
                        correct: 1,
                        explanation: "According to Table 13.3 on page 21 and the diagrams on page 28, a logical shift (`SHR`) always fills empty bit positions with 0. An arithmetic shift (`SAR`) fills the empty bit positions with a copy of the original sign bit, preserving the number's sign."
                    },
                    {
                        id: 22,
                        text: "Which x86 instruction transfers program control but does NOT save a return address?",
                        options: [
                            "CALL",
                            "JMP",
                            "RET",
                            "INT"
                        ],
                        correct: 1,
                        explanation: "Table 13.3 on page 22 describes `JMP Dest` as an instruction that \"Transfers program control to a different point in the instruction stream without recording return information.\" In contrast, `CALL` is specifically designed to save a return address for later use by a `RET` instruction."
                    },
                    {
                        id: 23,
                        text: "What processor action is common to both Arithmetic and Logical operations, according to Table 13.4?",
                        options: [
                            "Updating the program counter.",
                            "Performing a virtual-to-actual address transformation.",
                            "Issuing a command to an I/O module.",
                            "Setting condition codes and flags."
                        ],
                        correct: 3,
                        explanation: "Table 13.4 on page 23 lists \"Set condition codes and flags\" as an action for Arithmetic operations. It then states that Logical operations are the \"Same as arithmetic,\" implying they also perform this action."
                    },
                    {
                        id: 24,
                        text: "In the IBM EAS/390 data transfer operations (Table 13.5), what does the `STC` (Store Character) instruction do?",
                        options: [
                            "Transfers an 8-bit character from register to memory.",
                            "Transfers a 16-bit halfword from register to memory.",
                            "Transfers a 32-bit word from memory to register.",
                            "Transfers a 64-bit long word from register to memory."
                        ],
                        correct: 0,
                        explanation: "Table 13.5 on page 25 lists the `STC` mnemonic for the \"Store Character\" instruction. It shows that it transfers 8 bits and its description is \"Transfer from register to memory.\""
                    },
                    {
                        id: 25,
                        text: "Based on the table of Basic Logical Operations (Table 13.6), what is the result of `1 P=Q 0`?",
                        options: [
                            "1",
                            "0",
                            "Undefined",
                            "True"
                        ],
                        correct: 1,
                        explanation: "The `P=Q` column in Table 13.6 on page 27 represents logical equivalence (also known as XNOR). The result is 1 (true) if P and Q are the same, and 0 (false) if they are different. In the row where P=1 and Q=0, the inputs are different, so the result for `P=Q` is 0."
                    },
                    {
                        id: 26,
                        text: "What is the result of performing a \"Logical left shift (3 bits)\" on the 8-bit input `10100110`?",
                        options: [
                            "`00110000`",
                            "`11110100`",
                            "`00110101`",
                            "`10110000`"
                        ],
                        correct: 0,
                        explanation: "Table 13.7 on page 29 shows this exact calculation. A logical left shift moves all bits to the left and fills the vacant rightmost bits with 0s. Input: `10100110` Shifting left by 3 positions discards the three leftmost bits (`101`). The remaining 5 bits (`00110`) shift left, and three `0`s are added to the right, resulting in `00110000`."
                    },
                    {
                        id: 27,
                        text: "What is the result of performing a \"Right rotate (3 bits)\" on the 8-bit input `10100110`?",
                        options: [
                            "`00110000`",
                            "`11110100`",
                            "`11010100`",
                            "`10110000`"
                        ],
                        correct: 2,
                        explanation: "Table 13.7 on page 29 shows this exact calculation. A right rotate moves bits to the right, and any bits shifted out from the right end are wrapped around and inserted into the vacant positions at the left end. Input: `10100110` The 3 rightmost bits are `110`. The remaining bits shifted right by 3 are `000` + `10100` -> `00010100`. Wrap the `110` around to the empty leftmost positions: `110` + `10100` -> `11010100`."
                    },
                    {
                        id: 28,
                        text: "Which x86 instruction decrements the stack pointer and then copies the source operand to the new top of the stack?",
                        options: [
                            "PUSH",
                            "POP",
                            "MOV",
                            "XCHG"
                        ],
                        correct: 0,
                        explanation: "Table 13.3 on page 20 describes the `PUSH Source` instruction as: \"Decrements stack pointer (ESP register), then copies the source operand to the top of stack.\" This is the fundamental operation for adding an item to the stack in x86 architecture."
                    },
                    {
                        id: 29,
                        text: "System control instructions, which can only be executed when the processor is in a privileged state, are typically reserved for use by which entity?",
                        options: [
                            "The user application",
                            "The compiler",
                            "The operating system",
                            "The I/O hardware"
                        ],
                        correct: 2,
                        explanation: "Page 32 states, \"Typically these instructions are reserved for the use of the operating system.\" This is to protect the system's integrity, as these instructions can alter fundamental aspects of the machine's state."
                    },
                    {
                        id: 30,
                        text: "Which of the following is NOT listed on page 33 as a reason why transfer-of-control operations are required?",
                        options: [
                            "To execute instructions more than once (e.g., in loops).",
                            "To facilitate decision making in programs.",
                            "To break a task into smaller pieces (e.g., procedures).",
                            "To perform arithmetic and logical operations."
                        ],
                        correct: 3,
                        explanation: "Page 33 lists the first three options as key reasons for needing transfer-of-control operations. Performing arithmetic and logical operations falls under the \"Data processing\" category of instructions, not a reason for transferring control."
                    }
                ]
            },
            {
                section: "Advanced Control Flow and Architecture-Specific Features",
                questions: [
                    {
                        id: 31,
                        text: "Why is a skip instruction \"free to do other things\" besides just skipping, such as in the ISZ (Increment-and-skip-if-zero) instruction?",
                        options: [
                            "Because it does not require a destination address field.",
                            "Because it uses the accumulator for its operations.",
                            "Because it is a privileged instruction.",
                            "Because it is always executed in a single clock cycle."
                        ],
                        correct: 0,
                        explanation: "The diagram on page 35 explicitly states, \"Because the skip instruction does not require a destination address field it is free to do other things\". The bits that would have been used for an address can instead be used to specify another, simple operation."
                    },
                    {
                        id: 32,
                        text: "What are the two principal reasons given for the use of procedures in programming?",
                        options: [
                            "Speed and security",
                            "Economy and modularity",
                            "Simplicity and compatibility",
                            "Abstraction and encapsulation"
                        ],
                        correct: 1,
                        explanation: "Page 36 explicitly lists the \"Two principal reasons for use of procedures\" as \"Economy\" (allowing the same piece of code to be used many times) and \"Modularity\" (breaking a task into smaller, manageable pieces)."
                    },
                    {
                        id: 33,
                        text: "When using a stack to implement nested procedures (Figure 13.9), what essential piece of information is pushed onto the stack when a `CALL` instruction is executed?",
                        options: [
                            "The entire procedure being called.",
                            "The current value of the accumulator.",
                            "The return address.",
                            "The parameters for the procedure."
                        ],
                        correct: 2,
                        explanation: "The diagrams in Figures 13.8 and 13.9 on pages 37-38 illustrate that when a `CALL` is made, the return address (the address of the instruction immediately following the `CALL`) is pushed onto the stack. This allows the `RETURN` instruction to pop this address and resume execution at the correct point."
                    },
                    {
                        id: 34,
                        text: "Upon entry to a new procedure in the x86 architecture, which of the following steps must be performed?",
                        options: [
                            "Clear all general-purpose registers.",
                            "Push the current frame pointer on the stack.",
                            "Disable all interrupts.",
                            "Copy the EIP register to the EAX register."
                        ],
                        correct: 1,
                        explanation: "Page 40 lists four steps that must be performed upon entry to a new procedure. One of these critical steps is to \"Push the current frame pointer on the stack\" to save the context of the calling procedure's stack frame."
                    },
                    {
                        id: 35,
                        text: "In the x86 architecture, which status flag represents carrying or borrowing between half-bytes of an 8-bit arithmetic operation and is used in binary-coded decimal (BCD) arithmetic?",
                        options: [
                            "A (Auxiliary Carry)",
                            "C (Carry)",
                            "P (Parity)",
                            "Z (Zero)"
                        ],
                        correct: 0,
                        explanation: "Table 13.8 on page 41 defines the `A` (Auxiliary Carry) flag with this exact description: \"Represents carrying or borrowing between half-bytes of an 8-bit arithmetic or logic operation. Used in binary-coded decimal arithmetic.\""
                    },
                    {
                        id: 36,
                        text: "For an x86 conditional jump instruction, what condition is tested by the `JNE` (or `JNZ`) mnemonic?",
                        options: [
                            "Z = 1",
                            "Z = 0",
                            "C = 1",
                            "S = 1"
                        ],
                        correct: 1,
                        explanation: "Table 13.9 on page 42 shows the condition codes. For the symbol `NE, NZ` (Not Equal, Not Zero), the condition tested is `Z = 0`. This means the jump is taken if the Zero flag is not set (i.e., the result of the previous operation was not zero)."
                    },
                    {
                        id: 37,
                        text: "What does the MMX instruction `PADDUS [B, W]` do?",
                        options: [
                            "Parallel add with wraparound.",
                            "Subtract with saturation.",
                            "Add unsigned with saturation.",
                            "Parallel multiply and add."
                        ],
                        correct: 2,
                        explanation: "Table 13.10 on page 44 describes MMX instructions. `PADDUS` stands for Parallel ADD Unsigned with Saturation. Saturation arithmetic means that if a result overflows, it is clamped to the maximum possible value for that data type instead of wrapping around."
                    },
                    {
                        id: 38,
                        text: "In the MMX image compositing example (Figure 13.11), what is the purpose of the `punpckblw` instruction?",
                        options: [
                            "To pack 16-bit results back into 8-bit bytes.",
                            "To perform a bitwise XOR operation.",
                            "To unpack 8-bit pixel components into 16-bit words.",
                            "To multiply the subtract result by a fade value."
                        ],
                        correct: 2,
                        explanation: "The MMX code sequence on page 45 includes the comment \";unpack 4 pixels to 16 bits\" for the `punpckblw` (Unpack Low Bytes to Words) instruction. This is done to provide more room for intermediate calculations and prevent overflow when operating on 8-bit pixel values."
                    },
                    {
                        id: 39,
                        text: "Which category of ARM operations includes instructions for moving data between memory and registers?",
                        options: [
                            "Data-processing instructions",
                            "Branch instructions",
                            "Load and store instructions",
                            "Extend instructions"
                        ],
                        correct: 2,
                        explanation: "The diagram on page 46 shows \"Load and store instructions\" as one of the main ARM operation types. These instructions are fundamental for data movement between the processor's registers and the memory system."
                    },
                    {
                        id: 40,
                        text: "On an ARM processor, which condition is tested for the `MI` (Minus/negative) conditional execution?",
                        options: [
                            "Z = 1",
                            "C = 1",
                            "V = 1",
                            "N = 1"
                        ],
                        correct: 3,
                        explanation: "Table 13.11 on page 47 lists the conditions for ARM conditional execution. For the mnemonic `MI`, the condition tested is `N = 1`. The N flag is the Negative (or sign) flag, which is set if the result of an operation is negative."
                    }
                ]
            }
        ];

        let stats = {
            answered: 0,
            correct: 0,
            incorrect: 0,
            totalQuestions: 40
        };

        function generateQuiz() {
            const content = document.getElementById('quizContent');
            content.innerHTML = '';

            quizData.forEach(section => {
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'section';
                
                const sectionTitle = document.createElement('h2');
                sectionTitle.className = 'section-title';
                sectionTitle.textContent = section.section;
                sectionDiv.appendChild(sectionTitle);

                section.questions.forEach(question => {
                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'question';
                    questionDiv.innerHTML = `
                        <div class="question-header">Question ${question.id}</div>
                        <div class="question-content">
                            <div class="question-text">${question.text}</div>
                            <ul class="options">
                                ${question.options.map((option, index) => `
                                    <li class="option" data-index="${index}">
                                        <label>
                                            <input type="radio" name="q${question.id}" value="${index}">
                                            ${String.fromCharCode(65 + index)}. ${option}
                                        </label>
                                    </li>
                                `).join('')}
                            </ul>
                            <div class="explanation">
                                <strong>Explanation:</strong> ${question.explanation}
                            </div>
                        </div>
                    `;
                    
                    sectionDiv.appendChild(questionDiv);
                });

                content.appendChild(sectionDiv);
            });

            // Add event listeners to all radio buttons
            document.querySelectorAll('input[type="radio"]').forEach(radio => {
                radio.addEventListener('change', handleAnswer);
            });
        }

        function handleAnswer(event) {
            const questionId = parseInt(event.target.name.replace('q', ''));
            const selectedIndex = parseInt(event.target.value);
            
            // Find the question data
            let questionData = null;
            for (let section of quizData) {
                questionData = section.questions.find(q => q.id === questionId);
                if (questionData) break;
            }

            if (!questionData) return;

            // Get the question element
            const questionElement = event.target.closest('.question');
            const options = questionElement.querySelectorAll('.option');
            const explanation = questionElement.querySelector('.explanation');

            // Disable all radio buttons for this question
            questionElement.querySelectorAll('input[type="radio"]').forEach(radio => {
                radio.disabled = true;
            });

            // Mark correct and incorrect answers
            options.forEach((option, index) => {
                if (index === questionData.correct) {
                    option.classList.add('correct');
                } else if (index === selectedIndex) {
                    option.classList.add('incorrect');
                }
            });

            // Show explanation
            explanation.classList.add('show');

            // Update stats
            if (selectedIndex === questionData.correct) {
                stats.correct++;
            } else {
                stats.incorrect++;
            }
            stats.answered++;

            updateStats();
            
            // Check if quiz is complete
            if (stats.answered === stats.totalQuestions) {
                setTimeout(showFinalStats, 1000);
            }
        }

        function updateStats() {
            document.getElementById('progress').textContent = `${stats.answered}/${stats.totalQuestions}`;
            document.getElementById('correct').textContent = stats.correct;
            document.getElementById('incorrect').textContent = stats.incorrect;
            
            const percentage = stats.answered > 0 ? Math.round((stats.correct / stats.answered) * 100) : 0;
            document.getElementById('score').textContent = `${percentage}%`;
            
            const progressPercentage = (stats.answered / stats.totalQuestions) * 100;
            document.getElementById('progressFill').style.width = `${progressPercentage}%`;
        }

        function showFinalStats() {
            const finalScore = Math.round((stats.correct / stats.totalQuestions) * 100);
            document.getElementById('finalScore').textContent = `${finalScore}%`;
            
            let message = '';
            if (finalScore >= 90) {
                message = '🎉 Excellent! You have mastered instruction set concepts!';
            } else if (finalScore >= 80) {
                message = '👍 Great job! You have a solid understanding of processor instructions!';
            } else if (finalScore >= 70) {
                message = '👌 Good work! Consider reviewing some concepts to improve further.';
            } else if (finalScore >= 60) {
                message = '📚 Keep studying! You\'re on the right track but need more practice.';
            } else {
                message = '💪 Don\'t give up! Review the material and try again.';
            }
            
            document.getElementById('finalMessage').textContent = message;
            document.getElementById('finalStats').classList.add('show');
        }

        function restartQuiz() {
            stats = {
                answered: 0,
                correct: 0,
                incorrect: 0,
                totalQuestions: 40
            };
            
            document.getElementById('finalStats').classList.remove('show');
            updateStats();
            generateQuiz();
        }

        // Initialize quiz when page loads
        document.addEventListener('DOMContentLoaded', function() {
            generateQuiz();
            updateStats();
        });
    </script>
</body>
</html>
